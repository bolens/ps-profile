{
  "PowerShell Profile Script Template": {
    "prefix": "psprofile",
    "body": [
      "<#",
      "${1:script-name}",
      "",
      ".SYNOPSIS",
      "    ${2:Description of what the script does}",
      "",
      ".DESCRIPTION",
      "    ${3:Detailed description}",
      "",
      ".EXAMPLE",
      "    ${4:Example usage}",
      "#>",
      "",
      "# Import shared utilities",
      "$commonModulePath = Join-Path $PSScriptRoot 'Common.psm1'",
      "Import-Module $commonModulePath -DisableNameChecking -ErrorAction Stop",
      "",
      "# Get repository root using shared function",
      "try {",
      "    $repoRoot = Get-RepoRoot -ScriptPath $PSScriptRoot",
      "}",
      "catch {",
      "    Exit-WithCode -ExitCode $EXIT_SETUP_ERROR -ErrorRecord $_",
      "}",
      "",
      "${5:# Script logic here}",
      "",
      "Exit-WithCode -ExitCode $EXIT_SUCCESS"
    ],
    "description": "Template for PowerShell profile utility scripts"
  },
  "PowerShell Function with Comment-Based Help": {
    "prefix": "psfunc",
    "body": [
      "<#",
      ".SYNOPSIS",
      "    ${1:Function description}",
      "",
      ".DESCRIPTION",
      "    ${2:Detailed description}",
      "",
      ".PARAMETER ${3:ParameterName}",
      "    ${4:Parameter description}",
      "",
      ".EXAMPLE",
      "    ${5:Example usage}",
      "",
      ".OUTPUTS",
      "    ${6:Output type}",
      "#>",
      "function ${7:Function-Name} {",
      "    [CmdletBinding()]",
      "    [OutputType([${8:type}])]",
      "    param(",
      "        [Parameter(${9:Mandatory})]",
      "        [${10:string}]",
      "        `$${3:ParameterName}",
      "    )",
      "",
      "    ${11:# Function body}",
      "}"
    ],
    "description": "PowerShell function with comment-based help"
  },
  "PowerShell Try-Catch Block": {
    "prefix": "pstry",
    "body": [
      "try {",
      "    ${1:# Code that might throw}",
      "}",
      "catch {",
      "    ${2:Exit-WithCode -ExitCode $EXIT_SETUP_ERROR -ErrorRecord $_}",
      "}"
    ],
    "description": "PowerShell try-catch block with error handling"
  },
  "PowerShell Test Case": {
    "prefix": "pstest",
    "body": [
      "Describe '${1:Test Description}' {",
      "    It '${2:should do something}' {",
      "        ${3:# Arrange}",
      "        ${4:# Act}",
      "        ${5:# Assert}",
      "        ${6:result} | Should -Be ${7:expected}",
      "    }",
      "}"
    ],
    "description": "Pester test case template"
  },
  "PowerShell Test Context": {
    "prefix": "pstestctx",
    "body": [
      "Describe '${1:Test Suite}' {",
      "    Context '${2:Test Context}' {",
      "        BeforeAll {",
      "            ${3:# Setup}",
      "        }",
      "",
      "        AfterAll {",
      "            ${4:# Cleanup}",
      "        }",
      "",
      "        It '${5:should do something}' {",
      "            ${6:# Test implementation}",
      "        }",
      "    }",
      "}"
    ],
    "description": "Pester test context with BeforeAll/AfterAll"
  },
  "PowerShell Parameter Validation": {
    "prefix": "psparam",
    "body": [
      "[Parameter(${1:Mandatory})]",
      "[${2:string}]",
      "`$${3:ParameterName}${4:,}"
    ],
    "description": "PowerShell parameter declaration"
  },
  "PowerShell ValidateScript Parameter": {
    "prefix": "psvalidatescript",
    "body": [
      "[Parameter(Mandatory)]",
      "[ValidateScript({",
      "    if (${1:condition}) {",
      "        throw \"${2:Error message}\"",
      "    }",
      "    `$true",
      "})]",
      "[${3:string}]",
      "`$${4:ParameterName}"
    ],
    "description": "PowerShell parameter with ValidateScript"
  },
  "PowerShell Measure-Operation": {
    "prefix": "psmeasure",
    "body": [
      "`$metrics = Measure-Operation -ScriptBlock {",
      "    ${1:# Operation to measure}",
      "} -OperationName '${2:OperationName}'",
      "",
      "Write-Output \"Operation took `$(`$metrics.DurationMs)ms\""
    ],
    "description": "Measure operation execution time"
  },
  "PowerShell Parallel Processing": {
    "prefix": "psparallel",
    "body": [
      "`$results = Invoke-Parallel -Items `${${1:items}} -ScriptBlock {",
      "    param(`$Item)",
      "    ${2:# Process item}",
      "    return `$result",
      "} -ThrottleLimit ${3:5}"
    ],
    "description": "Process items in parallel"
  },
  "PowerShell Caching": {
    "prefix": "pscache",
    "body": [
      "# Check cache first",
      "`$cachedValue = Get-CachedValue -Key '${1:CacheKey}'",
      "if (`$null -ne `$cachedValue) {",
      "    return `$cachedValue",
      "}",
      "",
      "# Compute value",
      "`$value = ${2:# Compute value}",
      "",
      "# Cache result",
      "Set-CachedValue -Key '${1:CacheKey}' -Value `$value -ExpirationSeconds ${3:300}",
      "return `$value"
    ],
    "description": "Cache pattern with Get-CachedValue/Set-CachedValue"
  },
  "PowerShell OutputType Attribute": {
    "prefix": "psoutputtype",
    "body": [
      "[OutputType([${1:type}])]"
    ],
    "description": "OutputType attribute for function return type"
  },
  "PowerShell Type Constraint Parameter": {
    "prefix": "pstypeparam",
    "body": [
      "[Parameter(${1:Mandatory})]",
      "[${2:string}]",
      "`$${3:ParameterName}${4:,}"
    ],
    "description": "Parameter with type constraint"
  },
  "PowerShell ValidateSet Parameter": {
    "prefix": "psvalidateset",
    "body": [
      "[Parameter(${1:Mandatory})]",
      "[ValidateSet('${2:value1}', '${3:value2}', '${4:value3}')]",
      "[${5:string}]",
      "`$${6:ParameterName}"
    ],
    "description": "Parameter with ValidateSet constraint"
  },
  "PowerShell Path Validation Parameter": {
    "prefix": "pspathparam",
    "body": [
      "[Parameter(${1:Mandatory})]",
      "[ValidateScript({",
      "    if (`$_ -and -not (Test-Path `$_)) {",
      "        throw \"Path does not exist: `$_\"",
      "    }",
      "    `$true",
      "})]",
      "[${2:string}]",
      "`$${3:Path}${4:,}"
    ],
    "description": "Path parameter with validation"
  },
  "PowerShell Suppression Attribute": {
    "prefix": "pssuppress",
    "body": [
      "[Diagnostics.CodeAnalysis.SuppressMessageAttribute('${1:RuleName}', '', Justification = '${2:Reason for suppression}')]"
    ],
    "description": "PSScriptAnalyzer suppression attribute"
  },
  "PowerShell Function with Full Type Safety": {
    "prefix": "psfunctype",
    "body": [
      "<#",
      ".SYNOPSIS",
      "    ${1:Function description}",
      "",
      ".DESCRIPTION",
      "    ${2:Detailed description}",
      "",
      ".PARAMETER ${3:ParameterName}",
      "    ${4:Parameter description}",
      "",
      ".EXAMPLE",
      "    ${5:Example usage}",
      "",
      ".OUTPUTS",
      "    ${6:Output type description}",
      "#>",
      "function ${7:Function-Name} {",
      "    [CmdletBinding()]",
      "    [OutputType([${8:type}])]",
      "    param(",
      "        [Parameter(${9:Mandatory})]",
      "        [${10:string}]",
      "        `$${3:ParameterName}",
      "    )",
      "",
      "    ${11:# Function body with type-safe operations}",
      "}"
    ],
    "description": "Function template with full type safety (OutputType, type constraints)"
  },
  "PowerShell Error Handling with Exit-WithCode": {
    "prefix": "psexitcode",
    "body": [
      "try {",
      "    ${1:# Operation that might fail}",
      "}",
      "catch {",
      "    Exit-WithCode -ExitCode `$EXIT_${2:SETUP_ERROR} -ErrorRecord `$_",
      "}"
    ],
    "description": "Error handling pattern with Exit-WithCode"
  },
  "PowerShell List Collection": {
    "prefix": "pslist",
    "body": [
      "`$${1:list} = [System.Collections.Generic.List[${2:PSCustomObject}]]::new()",
      "`$${1:list}.Add(${3:item})"
    ],
    "description": "Generic List collection initialization"
  },
  "Profile Fragment: Set-AgentModeFunction": {
    "prefix": "psfragmentfunc",
    "body": [
      "Set-AgentModeFunction -Name '${1:Function-Name}' -Body {",
      "    ${2:# Function body}",
      "}${3: # ${4:Description}}"
    ],
    "description": "Create collision-safe function in profile fragment"
  },
  "Profile Fragment: Set-AgentModeAlias": {
    "prefix": "psfragmentalias",
    "body": [
      "Set-AgentModeAlias -Name '${1:alias}' -Target '${2:command}'${3: # ${4:Description}}"
    ],
    "description": "Create collision-safe alias in profile fragment"
  },
  "Profile Fragment: Command Check": {
    "prefix": "psfragmentcheck",
    "body": [
      "if (Test-CachedCommand '${1:command}') {",
      "    ${2:# Configure ${1:command} helpers}",
      "}"
    ],
    "description": "Check if external command is available before configuring"
  },
  "Profile Fragment: Lazy Function Registration": {
    "prefix": "psfragmentlazy",
    "body": [
      "Register-LazyFunction -Name '${1:Function-Name}' -Initializer {",
      "    ${2:# Initialization code}",
      "} -Alias '${3:alias}'"
    ],
    "description": "Register lazy-loading function stub"
  },
  "Profile Fragment: Enable Function Pattern": {
    "prefix": "psfragmentenable",
    "body": [
      "function Enable-${1:Feature} {",
      "    [CmdletBinding()]",
      "    param()",
      "    ",
      "    ${2:# Lazy initialization code}",
      "}"
    ],
    "description": "Enable function pattern for lazy loading"
  },
  "Profile Fragment: Idempotency Check": {
    "prefix": "psfragmentidempotent",
    "body": [
      "if (-not (Test-Path Function:\\${1:FunctionName})) {",
      "    function ${1:FunctionName} {",
      "        ${2:# Function body}",
      "    }",
      "}"
    ],
    "description": "Idempotent function definition check"
  },
  "Profile Fragment: Fragment Header": {
    "prefix": "psfragmentheader",
    "body": [
      "# ===============================================",
      "# ${1:NN-fragment-name}.ps1",
      "# ${2:Fragment description}",
      "#",
      "# Purpose: ${3:Purpose of this fragment}",
      "# Dependencies: ${4:none|command1,command2}",
      "# ==============================================="
    ],
    "description": "Standard profile fragment header"
  },
  "Pester: Describe Block": {
    "prefix": "pstestdescribe",
    "body": [
      "Describe '${1:Test Description}' {",
      "    ${2:# Test cases}",
      "}"
    ],
    "description": "Pester Describe block"
  },
  "Pester: Context Block": {
    "prefix": "pstestcontext",
    "body": [
      "Context '${1:Test Context}' {",
      "    ${2:# Test cases}",
      "}"
    ],
    "description": "Pester Context block"
  },
  "Pester: It Test Case": {
    "prefix": "pstestit",
    "body": [
      "It '${1:should do something}' {",
      "    ${2:# Arrange}",
      "    ${3:# Act}",
      "    ${4:# Assert}",
      "    ${5:result} | Should -Be ${6:expected}",
      "}"
    ],
    "description": "Pester It test case"
  },
  "Pester: BeforeAll Block": {
    "prefix": "pstestbeforeall",
    "body": [
      "BeforeAll {",
      "    ${1:# Setup code}",
      "}"
    ],
    "description": "Pester BeforeAll setup block"
  },
  "Pester: AfterAll Block": {
    "prefix": "pstestafterall",
    "body": [
      "AfterAll {",
      "    ${1:# Cleanup code}",
      "}"
    ],
    "description": "Pester AfterAll cleanup block"
  },
  "Pester: Should Assertion": {
    "prefix": "pstestshould",
    "body": [
      "${1:result} | Should -Be ${2:expected}${3: -Because \"${4:reason}\"}"
    ],
    "description": "Pester Should assertion"
  },
  "Pester: Mock Pattern": {
    "prefix": "pstestmock",
    "body": [
      "Mock -CommandName ${1:Command-Name} -MockWith {",
      "    ${2:# Mock implementation}",
      "    return ${3:value}",
      "}"
    ],
    "description": "Pester Mock pattern"
  },
  "Pester: Complete Test Suite": {
    "prefix": "pstestsuite",
    "body": [
      "<#",
      "tests/${1:test-file}.tests.ps1",
      "",
      "${2:Description of test suite}",
      "#>",
      "",
      "BeforeAll {",
      "    ${3:# Import modules and setup}",
      "}",
      "",
      "AfterAll {",
      "    ${4:# Cleanup}",
      "}",
      "",
      "Describe '${5:Test Suite}' {",
      "    Context '${6:Test Context}' {",
      "        It '${7:should do something}' {",
      "            ${8:# Test implementation}",
      "            ${9:result} | Should -Be ${10:expected}",
      "        }",
      "    }",
      "}"
    ],
    "description": "Complete Pester test suite template"
  },
  "Pester: Skipped Test": {
    "prefix": "pstestskipped",
    "body": [
      "Set-ItResult -Skipped -Because \"${1:Reason for skipping}\""
    ],
    "description": "Pester skipped test pattern"
  },
  "PowerShell If Statement": {
    "prefix": "psif",
    "body": [
      "if (${1:condition}) {",
      "    ${2:# Code to execute if true}",
      "}"
    ],
    "description": "PowerShell if statement"
  },
  "PowerShell If-Else Statement": {
    "prefix": "psifelse",
    "body": [
      "if (${1:condition}) {",
      "    ${2:# Code to execute if true}",
      "} else {",
      "    ${3:# Code to execute if false}",
      "}"
    ],
    "description": "PowerShell if-else statement"
  },
  "PowerShell For Loop": {
    "prefix": "psfor",
    "body": [
      "for (${1:$i = 0}; ${2:$i -lt $count}; ${3:$i++}) {",
      "    ${4:# Loop body}",
      "}"
    ],
    "description": "PowerShell for loop"
  },
  "PowerShell Foreach Loop": {
    "prefix": "psforeach",
    "body": [
      "foreach (${1:$item} in ${2:$collection}) {",
      "    ${3:# Loop body}",
      "}"
    ],
    "description": "PowerShell foreach loop"
  },
  "PowerShell While Loop": {
    "prefix": "pswhile",
    "body": [
      "while (${1:condition}) {",
      "    ${2:# Loop body}",
      "}"
    ],
    "description": "PowerShell while loop"
  },
  "PowerShell Do-While Loop": {
    "prefix": "psdowhile",
    "body": [
      "do {",
      "    ${1:# Loop body}",
      "} while (${2:condition})"
    ],
    "description": "PowerShell do-while loop"
  },
  "PowerShell Switch Statement": {
    "prefix": "psswitch",
    "body": [
      "switch (${1:variable}) {",
      "    ${2:value1} { ${3:# Action for value1} }",
      "    ${4:value2} { ${5:# Action for value2} }",
      "    default { ${6:# Default action} }",
      "}"
    ],
    "description": "PowerShell switch statement"
  },
  "PowerShell Here-String": {
    "prefix": "psherestring",
    "body": [
      "@\"",
      "${1:Content}",
      "\"@"
    ],
    "description": "PowerShell here-string"
  },
  "PowerShell Splatting": {
    "prefix": "pssplat",
    "body": [
      "$${1:params} = @{",
      "    ${2:Parameter1} = '${3:value1}'",
      "    ${4:Parameter2} = ${5:$value2}",
      "}",
      "${6:Command-Name} @${1:params}"
    ],
    "description": "PowerShell splatting parameters"
  },
  "PowerShell Class Definition": {
    "prefix": "psclass",
    "body": [
      "class ${1:ClassName} {",
      "    ${2:# Properties}",
      "    ${3:[string]}${4:PropertyName}",
      "",
      "    ${5:# Constructor}",
      "    ${1:ClassName}() {",
      "        ${6:# Constructor body}",
      "    }",
      "",
      "    ${7:# Methods}",
      "    [${8:void}] ${9:MethodName}() {",
      "        ${10:# Method body}",
      "    }",
      "}"
    ],
    "description": "PowerShell class definition"
  },
  "PowerShell Enum": {
    "prefix": "psenum",
    "body": [
      "enum ${1:EnumName} {",
      "    ${2:Value1}",
      "    ${3:Value2}",
      "    ${4:Value3}",
      "}"
    ],
    "description": "PowerShell enum definition"
  },
  "PowerShell Using Statement": {
    "prefix": "psusing",
    "body": [
      "using namespace ${1:System.Collections.Generic}",
      "using module ${2:ModuleName}"
    ],
    "description": "PowerShell using statements"
  },
  "PowerShell ValidateRange Parameter": {
    "prefix": "psvalidaterange",
    "body": [
      "[Parameter(Mandatory)]",
      "[ValidateRange(${1:1}, ${2:100})]",
      "[${3:int}]",
      "$${4:ParameterName}"
    ],
    "description": "Parameter with ValidateRange"
  },
  "PowerShell ValidateLength Parameter": {
    "prefix": "psvalidatelength",
    "body": [
      "[Parameter(Mandatory)]",
      "[ValidateLength(${1:1}, ${2:50})]",
      "[${3:string}]",
      "$${4:ParameterName}"
    ],
    "description": "Parameter with ValidateLength"
  },
  "PowerShell SupportsShouldProcess": {
    "prefix": "psshouldprocess",
    "body": [
      "[CmdletBinding(SupportsShouldProcess)]",
      "param()",
      "",
      "if ($$PSCmdlet.ShouldProcess('${1:Target}', '${2:Operation}')) {",
      "    ${3:# Operation code}",
      "}"
    ],
    "description": "CmdletBinding with SupportsShouldProcess"
  },
  "PowerShell ConfirmImpact": {
    "prefix": "psconfirmimpact",
    "body": [
      "[CmdletBinding(ConfirmImpact = '${1:High}')]",
      "param()",
      "",
      "${2:# Function body}"
    ],
    "description": "CmdletBinding with ConfirmImpact"
  },
  "PowerShell Dynamic Parameter": {
    "prefix": "psdynamicparam",
    "body": [
      "function ${1:Function-Name} {",
      "    [CmdletBinding()]",
      "    param(",
      "        [Parameter(Mandatory)]",
      "        [string]$$StaticParam",
      "    )",
      "",
      "    dynamicparam {",
      "        $${2:dynamicParamDictionary} = New-Object System.Management.Automation.RuntimeDefinedParameterDictionary",
      "",
      "        $${3:paramAttributes} = New-Object System.Collections.ObjectModel.Collection[System.Attribute]",
      "        $${3:paramAttributes}.Add((New-Object System.Management.Automation.ParameterAttribute))",
      "",
      "        $${4:param} = New-Object System.Management.Automation.RuntimeDefinedParameter('${5:DynamicParam}', [${6:string}], $${3:paramAttributes})",
      "        $${2:dynamicParamDictionary}.Add('${5:DynamicParam}', $${4:param})",
      "",
      "        return $${2:dynamicParamDictionary}",
      "    }",
      "",
      "    begin {",
      "        $${7:dynamicParamValue} = $$PSBoundParameters['${5:DynamicParam}']",
      "    }",
      "",
      "    process {",
      "        ${8:# Function body}",
      "    }",
      "}"
    ],
    "description": "Function with dynamic parameters"
  },
  "PowerShell Pipeline Function": {
    "prefix": "pspipeline",
    "body": [
      "function ${1:Function-Name} {",
      "    [CmdletBinding()]",
      "    param(",
      "        [Parameter(ValueFromPipeline)]",
      "        [${2:object}]",
      "        $${3:InputObject}",
      "    )",
      "",
      "    process {",
      "        ${4:# Process each pipeline input}",
      "        return $${3:InputObject}",
      "    }",
      "}"
    ],
    "description": "Function that accepts pipeline input"
  },
  "PowerShell Begin/Process/End": {
    "prefix": "psbeginprocessend",
    "body": [
      "function ${1:Function-Name} {",
      "    [CmdletBinding()]",
      "    param()",
      "",
      "    begin {",
      "        ${2:# Initialization code}",
      "    }",
      "",
      "    process {",
      "        ${3:# Processing code for each input}",
      "    }",
      "",
      "    end {",
      "        ${4:# Cleanup code}",
      "    }",
      "}"
    ],
    "description": "Function with begin/process/end blocks"
  },
  "PowerShell Try-Catch-Finally": {
    "prefix": "pstryfinally",
    "body": [
      "try {",
      "    ${1:# Code that might throw}",
      "}",
      "catch {",
      "    ${2:# Exception handling}",
      "}",
      "finally {",
      "    ${3:# Cleanup code}",
      "}"
    ],
    "description": "PowerShell try-catch-finally block"
  },
  "PowerShell Script Block": {
    "prefix": "psscriptblock",
    "body": [
      "$${1:scriptBlock} = {",
      "    param(${2:$param})",
      "    ${3:# Script block body}",
      "}"
    ],
    "description": "PowerShell script block"
  }
}


